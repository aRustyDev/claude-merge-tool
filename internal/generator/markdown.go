package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/arustydev/claude-merge/internal/config"
	"github.com/arustydev/claude-merge/internal/merger"
)

// GenerateMarkdown converts a config into markdown content
func GenerateMarkdown(cfg *config.Config) string {
	var builder strings.Builder

	// Write metadata as HTML comment
	builder.WriteString("<!-- Generated by claude-merge -->\n")
	if cfg.Metadata.Title != "" {
		builder.WriteString(fmt.Sprintf("<!-- Title: %s -->\n", cfg.Metadata.Title))
	}
	if cfg.Metadata.Version != "" {
		builder.WriteString(fmt.Sprintf("<!-- Version: %s -->\n", cfg.Metadata.Version))
	}
	builder.WriteString("\n")

	// Apply merge targets to merge points in sections
	processedConfig := applyMergeTargets(cfg)

	// Sort sections by order
	sections := sortSections(processedConfig.Sections)

	// Write each section
	for _, section := range sections {
		builder.WriteString(section.Content)
		builder.WriteString("\n\n")
	}

	return strings.TrimSpace(builder.String())
}

// sortSections returns sections sorted by their order field
func sortSections(sections map[string]config.Section) []config.Section {
	// First, collect all sections
	var list []config.Section
	for _, section := range sections {
		list = append(list, section)
	}

	// Sort by order
	sort.Slice(list, func(i, j int) bool {
		return list[i].Order < list[j].Order
	})

	return list
}

// applyMergeTargets applies merge targets to merge points in the content
func applyMergeTargets(cfg *config.Config) *config.Config {
	// Create a copy of the config
	result := &config.Config{
		Metadata:     cfg.Metadata,
		Sections:     make(map[string]config.Section),
		MergePoints:  cfg.MergePoints,
		MergeTargets: cfg.MergeTargets,
	}

	// Copy and process each section
	for name, section := range cfg.Sections {
		processedSection := section
		content := section.Content

		// Apply merge targets to this section's content
		for targetName, target := range cfg.MergeTargets {
			if mergePoint, exists := cfg.MergePoints[targetName]; exists {
				if strings.Contains(content, mergePoint.Placeholder) {
					// Apply the merge strategy
					oldContent := mergePoint.Default
					newContent := target.Content
					mergedContent := merger.ApplyStrategy(merger.MergeStrategy(target.Strategy), oldContent, newContent)

					// Replace the placeholder with the merged content
					content = strings.Replace(content, mergePoint.Placeholder, mergedContent, -1)
				}
			}
		}

		processedSection.Content = content
		result.Sections[name] = processedSection
	}

	return result
}