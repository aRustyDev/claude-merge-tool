package generator

import (
	"strings"
	"testing"

	"github.com/arustydev/claude-merge/internal/config"
	"github.com/stretchr/testify/assert"
)

func TestGenerateMarkdown(t *testing.T) {
	cfg := &config.Config{
		Metadata: config.Metadata{
			Title:   "Test Document",
			Version: "1.0.0",
		},
		Sections: map[string]config.Section{
			"header": {
				Order:   1,
				Content: "# Test Header\n\nThis is the header content.",
			},
			"body": {
				Order:   2,
				Content: "## Body Section\n\nThis is the body content.",
			},
			"footer": {
				Order:   3,
				Content: "## Footer\n\nThis is the footer.",
			},
		},
	}

	result := GenerateMarkdown(cfg)

	// Check metadata comments
	assert.Contains(t, result, "<!-- Generated by claude-merge -->")
	assert.Contains(t, result, "<!-- Title: Test Document -->")
	assert.Contains(t, result, "<!-- Version: 1.0.0 -->")

	// Check that sections are in order
	lines := strings.Split(result, "\n")
	headerIdx := -1
	bodyIdx := -1
	footerIdx := -1

	for i, line := range lines {
		if strings.Contains(line, "# Test Header") {
			headerIdx = i
		}
		if strings.Contains(line, "## Body Section") {
			bodyIdx = i
		}
		if strings.Contains(line, "## Footer") {
			footerIdx = i
		}
	}

	assert.True(t, headerIdx < bodyIdx, "Header should come before body")
	assert.True(t, bodyIdx < footerIdx, "Body should come before footer")
}

func TestGenerateMarkdown_EmptySections(t *testing.T) {
	cfg := &config.Config{
		Metadata: config.Metadata{
			Title: "Empty Test",
		},
		Sections: map[string]config.Section{},
	}

	result := GenerateMarkdown(cfg)

	// Should still have metadata
	assert.Contains(t, result, "<!-- Generated by claude-merge -->")
	assert.Contains(t, result, "<!-- Title: Empty Test -->")
}

func TestGenerateMarkdown_SingleSection(t *testing.T) {
	cfg := &config.Config{
		Metadata: config.Metadata{
			Title: "Single Section Test",
		},
		Sections: map[string]config.Section{
			"only": {
				Order:   1,
				Content: "# Only Section\n\nThis is the only content.",
			},
		},
	}

	result := GenerateMarkdown(cfg)

	assert.Contains(t, result, "# Only Section")
	assert.Contains(t, result, "This is the only content.")
}

func TestSortSections(t *testing.T) {
	sections := map[string]config.Section{
		"third": {Order: 3, Content: "Third"},
		"first": {Order: 1, Content: "First"},
		"second": {Order: 2, Content: "Second"},
	}

	sorted := sortSections(sections)

	assert.Len(t, sorted, 3)
	assert.Equal(t, "First", sorted[0].Content)
	assert.Equal(t, "Second", sorted[1].Content)
	assert.Equal(t, "Third", sorted[2].Content)
}

func TestSortSections_SameOrder(t *testing.T) {
	sections := map[string]config.Section{
		"a": {Order: 1, Content: "A"},
		"b": {Order: 1, Content: "B"},
		"c": {Order: 2, Content: "C"},
	}

	sorted := sortSections(sections)

	assert.Len(t, sorted, 3)
	// Within same order, the sorting should be deterministic but order doesn't matter for our use case
	assert.Equal(t, 1, sorted[0].Order)
	assert.Equal(t, 1, sorted[1].Order)
	assert.Equal(t, 2, sorted[2].Order)
}

func TestGenerateMarkdown_WithMergeTargets(t *testing.T) {
	cfg := &config.Config{
		Metadata: config.Metadata{
			Title: "Merge Test",
		},
		Sections: map[string]config.Section{
			"content": {
				Order:   1,
				Content: "# Content\n\n<!-- MERGE:example -->\n\nMore content.",
			},
		},
		MergePoints: map[string]config.MergePoint{
			"example": {
				Placeholder: "<!-- MERGE:example -->",
				Default:     "Default content",
			},
		},
		MergeTargets: map[string]config.MergeTarget{
			"example": {
				Strategy: "replace",
				Content:  "Merged content",
			},
		},
	}

	result := GenerateMarkdown(cfg)

	// Should apply merge targets
	assert.Contains(t, result, "Merged content")
	assert.NotContains(t, result, "<!-- MERGE:example -->")
	assert.NotContains(t, result, "Default content")
}